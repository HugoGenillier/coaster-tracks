#include "Visiteur.h" // Inclure le fichier d'en-tête de Visiteur avant tout autre fichier d'en-tête
#include "Attraction.h"

Visiteur::Visiteur(std::string nom, std::vector<Attraction>& attractions) {
	Nom = nom;
	TempsAttendu = 0;
	Etat = EtatVisiteur::EnDecision;
	Position = { 0, 0 };

	// Initialiser ListeAttractions avec toutes les attractions et marquer chaque attraction comme non visitée et non favorite
	for (auto& attraction : attractions) {
		ListeAttractions.push_back(std::make_tuple(&attraction, false, false));
	}

	// Choisir trois attractions au hasard et les marquer comme favorites
	std::random_device rd;
	std::mt19937 gen(rd());
	std::uniform_int_distribution<size_t> dist(0, ListeAttractions.size() - 1);

	for (int i = 0; i < 3; ++i) {
		size_t randomIndex = dist(gen);
		std::get<2>(ListeAttractions[randomIndex]) = true;
	}
}

Visiteur::Visiteur() {}

void Visiteur::AfficherDetails() const {
	std::cout << "Nom : " << Nom << ", Temps total d'attente : " << TempsAttendu << std::endl;
}

void Visiteur::ActiverVisiteur() {
	switch (Etat) {
	case EtatVisiteur::EnDecision:
		//std::cout << "Visiteur " << Nom << " est en train de faire une décision" << std::endl;
		FaireDecision();
		break;
	case EtatVisiteur::EnMarche:
		//std::cout << "Visiteur " << Nom << " va vers " << Objectif->GetNom() << " position : " << GetPosition().x << ", " << GetPosition().y << std::endl;
		DeplacerVersAttraction();
		break;
	case EtatVisiteur::EnFileAttente:
		//std::cout << "Visiteur " << Nom << " est en file d'attente" << std::endl;
		TempsAttendu += 1; // Incrémenter le temps d'attente du visiteur
		break;
	default:
		// Gérer d'autres états si nécessaire
		break;
	}
}

void Visiteur::DeplacerVersAttraction() {

	// Vérifier si le visiteur est déjà à l'emplacement de l'attraction
	if (Position == Objectif->GetPosition()) {
		// Le visiteur est arrivé à l'attraction, changer son état en EnFileAttente
		Etat = EtatVisiteur::EnFileAttente;
		// Ajouter le visiteur à la file d'attente de l'attraction
		Objectif->AjouterVisiteur(this); // Assurez-vous que Objectif est un pointeur
	}
	else {
		// Calculer le déplacement vers l'attraction
		// Pour simplifier, vous pouvez implémenter un déplacement linéaire
		double deltaX = Objectif->GetPosition().x - Position.x;
		double deltaY = Objectif->GetPosition().y - Position.y;

		// Calculer le déplacement horizontal et vertical
		double deplacementX = (deltaX != 0) ? deltaX / abs(deltaX) : 0.0;
		double deplacementY = (deltaY != 0) ? deltaY / abs(deltaY) : 0.0;

		// Mettre à jour la position du visiteur
		Position.x += deplacementX;
		Position.y += deplacementY;
	}
}

void Visiteur::FaireDecision() {
	// Déterminer l'attraction la plus attrayante non visitée
	Attraction* meilleureAttraction = nullptr;
	double meilleurScore = -1; // Initialiser à un score très bas

	for (auto& attractionTuple : ListeAttractions) {
		Attraction* attraction = std::get<0>(attractionTuple);
		bool estDejaVisitee = std::get<1>(attractionTuple);
		bool estFavorite = std::get<2>(attractionTuple); // Ajout de cette fonction pour vérifier si l'attraction est favorite

		if (!estDejaVisitee) { // Vérifier si l'attraction n'a pas encore été visitée
			// Calculer le score d'attractivité de cette attraction
			double score = 0.0;

			// Calculer la distance entre le visiteur et l'attraction
			double distance = std::sqrt(std::pow(Position.x - attraction->GetPosition().x, 2) +
				std::pow(Position.y - attraction->GetPosition().y, 2));

			// Si la distance est nulle, cela signifie que le visiteur est déjà à l'attraction
			if (distance == 0) {
				score = std::numeric_limits<double>::infinity(); // Affecter une valeur infinie au score
			}
			else {
				// Calculer le score basé sur la distance et le temps d'attente actuel
				if (attraction->TempsAttenteEstime() != 0) {
					score = 1 / distance * (1 / (5 * attraction->TempsAttenteEstime()));
				}
				else {
					// Si le temps d'attente estimé est nul, affecter une valeur très basse au score
					score = std::numeric_limits<double>::max();
				}
			}

			// Appliquer un poids supplémentaire si l'attraction est favorite
			if (estFavorite) {
				score+=1/1000;
				score *= 10;
			}

			// Si le score est plus élevé que le meilleur score actuel, mettre à jour l'attraction choisie
			if (score > meilleurScore) {
				meilleureAttraction = attraction;
				meilleurScore = score;
			}
		}
	}

	// Si une attraction a été trouvée, mettre à jour l'objectif du visiteur
	if (meilleureAttraction != nullptr) {
		Objectif = meilleureAttraction;
		Etat = EtatVisiteur::EnMarche; // Changer l'état en EnMarche pour se déplacer vers la meilleure attraction
	}
}

void Visiteur::AjouterAttractionVisitee(Attraction* attraction) {
	// Parcourir le vecteur des attractions du visiteur
	for (auto& attractionTuple : ListeAttractions) {
		// Si l'attraction correspond à celle visitée
		if (std::get<0>(attractionTuple) == attraction) {
			// Mettre à jour le booléen associé à cette attraction
			std::get<1>(attractionTuple) = true;
			break; // Sortir de la boucle une fois que l'attraction a été trouvée
		}
	}
}

void Visiteur::ChangerComportement(EtatVisiteur nouvelEtat) {
	Etat = nouvelEtat;
}

std::string Visiteur::GetNom() const {
	return Nom;
}

Visiteur::~Visiteur() {}